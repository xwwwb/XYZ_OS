# XYZ OS🐧

本仓库负责存储郑州轻工业大学计算机学院操作系统课程设计代码

🥳 本项目将依托《30 天自制操作系统》从零开始制作一个操作系统 🎉

| 日期 | 进度             | 备注                                                                                   |
| ---- | ---------------- | -------------------------------------------------------------------------------------- |
| day1 | 已完成 2023-5-28 | 可以调用显卡 BIOS 中断显示字符 🎊Hello World!                                          |
| day2 | 已完成 2023-5-28 | 前 512 字节的磁盘文件生成和完整镜像生成，makefile 文件完善 💾disk!                     |
| day3 | 已完成 2023-5-29 | C 语言导入，从磁盘读入 10 个柱面 🥲 好难                                               |
| day4 | 已完成 2023-5-29 | 已经可以基本显示画面了 🥳 逐渐感觉到有意思了                                           |
| day5 | 已完成 2023-5-31 | 了解了结构体的内存分布和使用，新增的 GDT 和 IDT 部分很迷糊 😫 很晕...                  |
| day6 | 已完成 2023-5-31 | PIC 也很迷糊，中断处理程序作用是保护 CPU 现场，结合 day5 可以理解一点 🤨 很晕...       |
| day7 | 已完成 2023-6-1  | 理解了 FIFO 先进先出的实现，将其应用在处理键盘和鼠标的中断处理中 🥱 相对于前两天好理解 |
| day8 | 已完成 2023-6-1  | 解析鼠标传入的信号，获得点击和移动事件，修改图形显示代码，实现鼠标的移动 🤩 很有成就感 |

## 项目结构

```
- src             # 项目代码
  - 01_day
  - 02_day
  - 03_day
  ...
- README.md       # 总介绍文件

- index.html      # web entry   不用关心
- docs            # web code    不用关心
- image_md        # 图片存储
```

## 疑问

- [x] 书本 P80-84 调色板部分代码尚未查阅资料理解

  [《30天自制操作系统》学习笔记——第四天_调色板的访问模式_cer_ml的博客-CSDN博客](https://blog.csdn.net/applenob/article/details/19134911)

  以及为什么调色版中RGB除以4：

  > 在这段代码中，通过向 VGA 显示器的 0x03c9 端口写入 RGB 颜色来设置调色板。由于 VGA 显示器使用 6 位（2^6=64）来表示每个颜色通道的亮度值，因此将每个颜色通道的值除以 4 可以将 8 位（2^8=256）的颜色范围缩小到 6 位的颜色范围内，并且保留了更高的灰阶级别。

- [x] 书本 P100 鼠标背景显示函数的实际意义？

- [x] 书本 P113 LGDT 的计算没看懂

  >ESP寄存器 第四位开始存储 0000ffff 第六位存储 00270000 从第4位开始计算
  >
  >FF FF 00 00 00 27 00 00
  >
  >4  5  6  7  8  9  10 11
  >
  >而GDTR48位寄存器 也就是 6字节 低16位是段上限 其余32位是开始地址 即最初两个字节是段上限其余四个字节是开始地址
  >
  >需要的结果为 FF FF 00 27 00 00
  >
  >_load_gdtr:
  >
  >  MOV  AX,[ESP+4]
  >
  >  MOV  [ESP+6],AX
  >
  >  LGDT  [ESP+6]
  >
  >  RET
  >
  >以上代码 AX中先存放 FF FF
  >
  >然后将FF FF 放入 ESP+6 此时ESP为
  >
  >FF FF FF FF 00 27 00 00
  >
  >4  5  6  7  8  9  10 11
  >
  >此时在读取ESP+6就是FF FF 00 27 00 00

- [x] 代码 day6 25 26 行没看懂

  >在PIC上打开键盘和鼠标的中断

- [x] 代码 汇编 OUT 和 IN 是怎么工作的

  > 向设备端口写入和读取 查表才可以

- [x] 书本 day5-6 还是由很多疑问 GDT IDT PIC 等

  > 我理解PIC为可编程中断控制，在IDT中注册中断的处理函数，在PIC中开启中断，才可以接收到中断
  >
  > 注册IDT的时候 传入的2就是GDT中注册过的第二段，第二段好像存储着当前C语言编译产物，2 * 8 就是段地址，第二段，传入的函数就是偏移地址，即中断处理程序入口。2 * 8是因为段选择器第三位必须为0，应该是权限，0是最高权限
  >
  > IDT的具体要求还不是很了解 以及为什么C语言编译产物在第二段内存中 二段的地址注册为0x00280000 难道C语言产物运行也从0x00280000开始吗？
  >
  > 课本P157说了确实是这样 bootpack开始512复制到了0x00280000，所以GDT的第二段正好就是当前C语言产物的运行地址
  > #define LIMIT_GDT   0x0000ffff
  > #define ADR_BOTPAK    0x00280000
  > #define AR_DATA32_RW  0x4092
  > #define AR_CODE32_ER  0x409a
  >
  > set_segmdesc(gdt + 1, 0xffffffff,  0x00000000, AR_DATA32_RW); // 系统专用 可读写段 不可执行
  >
  > set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER); // 系统专用，可执行段，可读不可写
  >
  > 段2的作用就是存放bootpack的代码 bootpack以ORG 0为前提翻译的
  >
  > 段1是4G CPU能管理的全部内存 具体作用还未知

- [x] 书本 P123 DS 也好 ES 也好 SS 也好 这句话没看懂

  >**chatgpt**的回答：还是一头雾水
  >
  >在实模式下，CPU 使用段地址和偏移地址的方式来访问内存。当 CPU 执行指令时，会将段地址和偏移地址合并成一个物理地址，以访问内存中的数据。
  >
  >在这段汇编代码中，将 SS、DS 和 ES 寄存器都设置为相同的值，主要是为了使它们都指向系统的数据段（data segment），从而能够在其中正确地访问变量和数据结构。
  >
  >由于在实模式下，操作系统只能访问 1MB 的物理内存空间，因此将 SS、DS 和 ES 寄存器都设置为相同的值也可以最大化地利用可用的内存空间，从而提高程序的效率。
  >
  >另外，在保护模式下，为了提高系统的安全性，SS、DS 和 ES 寄存器的值通常会分别指向不同的内存段，以避免程序意外地修改关键数据。

- [x] 书本 day8 的通往 32 位模式的跳转代码没看懂 但是不影响接下来的学习

- [x] 第十天的叠加处理，最后的优化算法没看懂 但是不影响接下来的学习

- [x] 第十一天消除闪烁 最后的优化算法没理解透彻 但是不影响接下来的学习

- [x] 第十二天的加快中断算法 没有看的很懂 已经全部看懂了

- [x] 第十三天的算法

  >harib10h 因为中断处理程序中存在数组的移位，这里换了类似链表的数据结构 避免了移位 加快了速度
  >
  >具体算法没有深究，不影响看下去
  >
  >哨兵完全没看懂
<<<<<<< HEAD

- [ ] 第十六天算法 没看懂

  > 任务管理，没有逐句读代码


=======
  

- [ ] 多任务没看懂 第17天的代码 多任务切换的时候 应该不能多次执行console_task的吧，这里面包括了初始化

  > 是不是实际上多任务是记住了运行位置 然后接着运行位置？ 怎么实现的

- [ ] cmdline运行完一个程序后 如何清空的
>>>>>>> b6a00ab932c1788c30d7511966f2a1659f6075e5

## 实验截图

### 第一天

<img src="./image_md/image-20230529210641118.png" alt="image-20230529210641118" style="zoom:50%;" />

### 第二天

和第一天的运行结果一致：

<img src="./image_md/image-20230529210847550.png" alt="image-20230529210847550" style="zoom:80%;" />

附上 VMware 的运行结果和裸机运行结果

<img src="./image_md/image-20230529211029376.png" alt="image-20230529211029376" style="zoom:80%;" />

<img src="./image_md/image-20230529211606790.png" alt="image-20230529211606790" style="zoom:80%;" />

### 第三天

可以显示一个黑色的画面

 <img src="./image_md/image-20230529211242634.png" alt="image-20230529211242634" style="zoom:80%;" />

### 第四天

C 语言汇编混合编程 汇编实现了几个函数

这里两个实验结果 使用 makefile 的变量切换编译的文件

一个是结合了计算机图形学的简单算法绘制图像 直接读写显存

一个是书本的运行结果

<img src="./image_md/image-20230529211428060.png" alt="image-20230529211428060" style="zoom:80%;" />

<img src="./image_md/image-20230529211749295.png" alt="image-20230529211749295" style="zoom:80%;" />

### 第五天

结构体在内存中顺序存储，结构体指针指向结构体的首地址，结构体各个元素都可以按顺序用箭头访问到

然后使用了字符点阵的形式表示单个字符，这里对以下输出算法做个简单的例子

```C
int main(){
    static char font_A[16] = {
		0x00, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24,
		0x24, 0x7e, 0x42, 0x42, 0x42, 0xe7, 0x00, 0x00
	};

	putfont8(binfo->vram, binfo->scrnx, 10, 10, COL8_FFFFFF, font_A);
}
void putfont8(char *vram, int xsize, int x, int y, char c, char *font)
{
	int i;
	char *p, d /* data */;
	for (i = 0; i < 16; i++) {
		p = vram + (y + i) * xsize + x;
		d = font[i];
		if ((d & 0x80) != 0) { p[0] = c; }
		if ((d & 0x40) != 0) { p[1] = c; }
		if ((d & 0x20) != 0) { p[2] = c; }
		if ((d & 0x10) != 0) { p[3] = c; }
		if ((d & 0x08) != 0) { p[4] = c; }
		if ((d & 0x04) != 0) { p[5] = c; }
		if ((d & 0x02) != 0) { p[6] = c; }
		if ((d & 0x01) != 0) { p[7] = c; }
	}
	return;
}
```

以上 font_A 存储了 A 字符的点阵信息

<img src="./image_md/image-20230601113822518.png" alt="image-20230601113822518" style="zoom:25%;" />

```
// 对以上代码进行分析
// 13行的for就是循环点阵每一行 16-23的判断就是输出每一行中的每一列
// 以第三行 00011000为例 此时d为0x18 也就是00011000
16行
00011000
10000000
-------- &
00000000
不显示字符

19行
00011000
00010000
-------- &
00010000
显示字符

由此可知
使用按位递减的与操作，可以判断出d的每一位是不是1 从而决定该像素是否被渲染
```

这里将 A 的字符点阵进行修改 倒数第三行全部换成 1

新的 font_A

```c
static char font_A[16] = {
	0x00, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24,
	0x24, 0x7e, 0x42, 0x42, 0x42, 0xff, 0x00, 0x00
};
```

![image-20230601114415509](./image_md/image-20230601114415509.png)

在第五天我们还研究出如何更改入口函数

是很蹩脚的方法，仅在这里做简单说明，没有找到更好的办法前，还是使用默认的入口函数

在 naskfunc.nas 添加以下语句，声明原本的入口函数后 调用自己的入口函数名称 根据汇编规则前面加\_

为了防止报错 还要 EXTERN 这个标识符 也要把 HariMain 暴漏出去

<img src="./image_md/image-20230601115109731.png" alt="image-20230601115109731" style="zoom:50%;" />

<img src="./image_md/image-20230601115005589.png" alt="image-20230601115005589" style="zoom:60%;" />

### 第六天

第六天主要做了文件分割

将 C 语言分割为多个带源文件和头文件的文件

然后做了 PIC 的初始化可以接收中断

然后使用栈的数据结构做了 CPU 现场保护

即需要调用中断处理程序前，需要保存 CPU 当前寄存器的所有值

调用后恢复所有值 CPU 回到正常运行

具体原理有些难 还在研读中

![image-20230601120007632](./image_md/image-20230601120007632.png)

### 第七天

书本126页有写 0x60+IRQ号输出给OCW2 重启键盘的中断检测

```C
void inthandler21(int *esp)
{
	unsigned char data;
	io_out8(PIC0_OCW2, 0x61); // 键盘是IRQ1 鼠标是IRQ12
	data = io_in8(PORT_KEYDAT);
	fifo8_put(&keyfifo, data);
	return;
}

struct FIFO8 mousefifo;

void inthandler2c(int *esp)
/* PS/2�}�E�X����̊��荞�� */
{
	unsigned char data;
	io_out8(PIC1_OCW2, 0x64);	// IRQ12位于从PIC的第四个地址
	io_out8(PIC0_OCW2, 0x62);	// 通知PIC0 IRQ2的受理完成
	data = io_in8(PORT_KEYDAT);
	fifo8_put(&mousefifo, data);
	return;
}
```

harib04g 新增代码为开启鼠标电路 有关重启中断的讲解也在上面写了

### 第八天

鼠标解读算法由于是定式 不做细致研究

进入32位的代码 还有些不明白 但是暂时不必深究

主程序中 初始化gdt和pic后执行的io_sti()是为了回应asmhead.nas中的`禁止CPU中断`

### 第十四天

[CMOS - OSDev Wiki](https://wiki.osdev.org/CMOS)

尝试引入了CMOS端口

### 第十五天

任务调度

### 第十六天

后面的算法有些没看懂，先跳过

### 第十七天
